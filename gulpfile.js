const gulp = require('gulp');
const through2 = require('through2');
const gettextParser = require('gettext-parser');
const fs = require('fs');
const path = require('path');
const chalk = require('chalk');
const { glob } = require('glob');

/**
 * Convert PO file to MO (binary format)
 */
function po2mo() {
    return through2.obj(function (file, enc, cb) {
        if (file.isNull()) {
            return cb(null, file);
        }

        if (file.isStream()) {
            this.emit('error', new Error('Streams not supported!'));
            return cb();
        }

        try {
            // Parse PO file
            const po = gettextParser.po.parse(file.contents);

            // Convert to MO
            const mo = gettextParser.mo.compile(po);

            // Update file contents and extension
            file.contents = mo;
            file.extname = '.mo';

            console.log(chalk.green('âœ“'), 'Generated MO:', chalk.cyan(file.relative));

            cb(null, file);
        } catch (err) {
            console.log(chalk.red('âœ—'), 'Error processing:', file.relative, err.message);
            cb();
        }
    });
}

/**
 * Convert PO file to L10N.php (WordPress 6.5+ optimized format)
 */
function po2php() {
    return through2.obj(function (file, enc, cb) {
        if (file.isNull()) {
            return cb(null, file);
        }

        if (file.isStream()) {
            this.emit('error', new Error('Streams not supported!'));
            return cb();
        }

        try {
            // Parse PO file
            const po = gettextParser.po.parse(file.contents);
            const translations = po.translations[''] || {};

            // Build PHP array
            let phpContent = '<?php\n';
            phpContent += '// This file is automatically generated. Do not edit manually.\n';
            phpContent += 'return array(\n';

            for (const [msgid, data] of Object.entries(translations)) {
                // Skip header entry
                if (msgid === '') continue;

                const msgstr = data.msgstr[0];
                if (!msgstr) continue;

                // Escape quotes and backslashes for PHP
                const escapedMsgid = msgid.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                const escapedMsgstr = msgstr.replace(/\\/g, '\\\\').replace(/'/g, "\\'");

                phpContent += `\t'${escapedMsgid}' => '${escapedMsgstr}',\n`;
            }

            phpContent += ');\n';

            // Update file contents and extension
            file.contents = Buffer.from(phpContent);
            file.extname = '.l10n.php';

            console.log(chalk.green('âœ“'), 'Generated PHP:', chalk.cyan(file.relative));

            cb(null, file);
        } catch (err) {
            console.log(chalk.red('âœ—'), 'Error processing:', file.relative, err.message);
            cb();
        }
    });
}

/**
 * Build task: Generate MO and L10N.php files from all PO files
 */
async function build() {
    console.log(chalk.blue.bold('\nðŸ”¨ Building translation files...\n'));

    // Find all PO files
    const poFiles = await glob('**/*.po', {
        ignore: ['node_modules/**', '.git/**']
    });

    if (poFiles.length === 0) {
        console.log(chalk.yellow('âš '), 'No PO files found');
        return Promise.resolve();
    }

    console.log(chalk.blue('â„¹'), `Found ${poFiles.length} PO file(s)\n`);

    // Process each PO file
    for (const poFile of poFiles) {
        const dir = path.dirname(poFile);
        const basename = path.basename(poFile, '.po');

        try {
            const poContent = fs.readFileSync(poFile);

            // Generate MO file
            const po = gettextParser.po.parse(poContent);
            const mo = gettextParser.mo.compile(po);
            const moPath = path.join(dir, `${basename}.mo`);
            fs.writeFileSync(moPath, mo);
            console.log(chalk.green('âœ“'), 'Generated MO:', chalk.cyan(moPath));

            // Generate L10N.php file
            const translations = po.translations[''] || {};
            let phpContent = '<?php\n';
            phpContent += '// This file is automatically generated. Do not edit manually.\n';
            phpContent += 'return array(\n';

            for (const [msgid, data] of Object.entries(translations)) {
                if (msgid === '') continue;
                const msgstr = data.msgstr[0];
                if (!msgstr) continue;

                const escapedMsgid = msgid.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                const escapedMsgstr = msgstr.replace(/\\/g, '\\\\').replace(/'/g, "\\'");

                phpContent += `\t'${escapedMsgid}' => '${escapedMsgstr}',\n`;
            }

            phpContent += ');\n';

            const phpPath = path.join(dir, `${basename}.l10n.php`);
            fs.writeFileSync(phpPath, phpContent);
            console.log(chalk.green('âœ“'), 'Generated PHP:', chalk.cyan(phpPath));

        } catch (err) {
            console.log(chalk.red('âœ—'), 'Error processing:', poFile, err.message);
        }
    }

    console.log(chalk.green.bold('\nâœ… Build complete!\n'));
    return Promise.resolve();
}

/**
 * Watch task: Watch for PO file changes and rebuild
 */
function watch() {
    console.log(chalk.blue.bold('\nðŸ‘€ Watching for changes...\n'));
    return gulp.watch(['plugins/**/*.po', 'themes/**/*.po'], build);
}

exports.build = build;
exports.watch = watch;
exports.default = build;
